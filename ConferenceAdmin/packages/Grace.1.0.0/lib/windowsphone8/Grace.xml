<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Grace</name>
    </assembly>
    <members>
        <member name="T:Grace.Data.IExtraDataContainer">
            <summary>
            
            </summary>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="T:Grace.Data.NotifyObject">
            <summary>
            A base object that implements INotifyPropertyChanged and offers logging
            </summary>
        </member>
        <member name="M:Grace.Data.NotifyObject.SetProperty``1(``0@,``0,System.String)">
            <summary>
            Sets a value to a particular property while calling PropertyChanged
            Note: Default implementation from VS temlate
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="storage">backing field for the property</param>
            <param name="value">new value to set</param>
            <param name="propertyName">property name (usually left blank if calling from property)</param>
            <returns>true if the value was set (false if its the same value)</returns>
        </member>
        <member name="M:Grace.Data.NotifyObject.OnPropertyChanged(System.String)">
            <summary>
            Default implementation of Propertychanged event invoker
            </summary>
            <param name="propertyName">property that changed</param>
        </member>
        <member name="P:Grace.Data.NotifyObject.Log">
            <summary>
            ILog instance for this class
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ActivationCompleteAttribute">
            <summary>
            Methods that are attributed with this class will be called at the end of activation
            Note: the signature must be Action() or Action(IInjectionContext)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IActivationCompleteAttribute">
            <summary>
            Attibutes that implement this interface will be discovered during scanning
            It is to be used on methods that are to be called during activation
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportAttribute">
            <summary>
            This attribute is used to mark a type for export. 
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute">
            <summary>
            Attributes that implement this interface will be included while scanning for exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provide a list of export names that the type should be exported as
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>list of export names</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor">
            <summary>
            Default constructor. Export as the class name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor(System.String,System.String[])">
            <summary>
            exports using the provided export name
            </summary>
            <param name="exportName"></param>
            <param name="extraNames"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor(System.Type,System.Type[])">
            <summary>
            Export by type rather than by name
            </summary>
            <param name="exportType"></param>
            <param name="extraTypes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provide a list of export names that the type should be exported as
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>list of export names</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ExportAttribute.ExportNames">
            <summary>
            The list of export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ExportAttribute.ExportTypes">
            <summary>
            List of export types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute">
            <summary>
            Limits an export to only be used when the class it's being injected into has the specified attribute
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute">
            <summary>
            Attributes that implement this interface can provide a condition for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default constructor that takes an attribute type to filter on
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide a condition for the type provided
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute">
            <summary>
            Attributes that implement this interface will be included while discovering attributes for importing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.ImportName">
            <summary>
            Import name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.Required">
            <summary>
            Is this import required. True by default
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ICustomInitializationAttribute">
            <summary>
            Attributes that implement this inteface will be used during discovery
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IEnrichWithAttribute">
            <summary>
            Attributes that implement will be called at discovery time to provide an EnrichWithDelegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IEnrichWithAttribute.ProvideDelegate(System.Type)">
            <summary>
            Provides an EnrichWithDelegate for an attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportEnvironmentAttribute">
            <summary>
            Attributes that implement this interface will be called during discovery time
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportEnvironmentAttribute.ProvideEnvironment(System.Type)">
            <summary>
            Provide the environment for the specified type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>export environment</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute">
            <summary>
            Attributes that implement this interface will be called during discovery to provide metadata for an attributed type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute.ProvideMetadata(System.Type)">
            <summary>
            Provide the metadata for an attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>a named piece of metadata</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute">
            <summary>
            Attributes that implement this interface will be called during discover to provide a priority
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute.ProvidePriority(System.Type)">
            <summary>
            Provide the priority for an attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute">
            <summary>
            Attributes that implement this interface will be called at discovery time to provide an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute.ProvideStrategy(System.Type)">
            <summary>
            Provide an export strategy for the attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo">
            <summary>
            Information about how the import should be performed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ImportName">
            <summary>
            The name of the import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ImportKey">
            <summary>
            The key that should be used when importing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ValueProvider">
            <summary>
            Value provider to use instead of looking up value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ExportStrategyFilter">
            <summary>
            Import Filter 
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportValueProviderAttribute">
            <summary>
            Import attributes that implement this attribute can be used to import a particular value provider into 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportValueProviderAttribute.ProvideProvider(System.Type)">
            <summary>
            Provide an IExportValueProvider to be used on import
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ILifeCycleProviderAttribute">
            <summary>
            Attributes that implement this interface will be queried during discovery to provide a life cycle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.ILifeCycleProviderAttribute.ProvideLifeCycle(System.Type)">
            <summary>
            Provide a lifecycle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ImportAttribute">
            <summary>
            This attribute can be used to attribute properties, methods, constructors or parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Name">
            <summary>
            Name to use when importing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Key">
            <summary>
            Key to use when importing 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Required">
            <summary>
            Is this import required. True by default
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonAttribute">
            <summary>
            Exports attribute with this attribute will be shared as a single instance for all scopes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonAttribute.ProvideLifeCycle(System.Type)">
            <summary>
            Provide a lifecycle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerInjectionContextAttribute">
            <summary>
            Exports marked with this attribute will be shared per injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerInjectionContextAttribute.ProvideLifeCycle(System.Type)">
            <summary>
            Provide a lifecycle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute">
            <summary>
            Exports that are marked with this attribute will be shared per request.
            Note: request has different meanings in different contexts.
            WCF - limited to per WCF operation
            MVC - Per HTTP Request
            Other - without a context the export will be shared for the injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute.ProvideLifeCycle(System.Type)">
            <summary>
            Provide a lifecycle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute">
            <summary>
            Exports marked with this attribute will be shared per scope.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute.ProvideLifeCycle(System.Type)">
            <summary>
            Provide a lifecycle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WeakSingletonAttribute">
            <summary>
            Exports attributed with this will be shared, the instance will be held with a weak reference so it will be GC'd when done
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WeakSingletonAttribute.ProvideLifeCycle(System.Type)">
            <summary>
            Provide a lifecycle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenClassHasAttribute">
            <summary>
            Export condition that limits the export to only be used in classes that have a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provides a new WhenClassHas condition
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute">
            <summary>
            Limits an export to only be used when being injected into one of the types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute">
            <summary>
            Limits an export to only be used when the importing member has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute">
            <summary>
            Limits an export to only be used when the target has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.IExportCondition">
            <summary>
            any class that implements this interface can be used as a condition on an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.IExportCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.MultipleConditions">
            <summary>
            Combines multiple conditions into one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.MultipleConditions.#ctor(Grace.DependencyInjection.Conditions.IExportCondition[])">
            <summary>
            Default Constructor
            </summary>
            <param name="exportConditions"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.MultipleConditions.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.UnlessCondition">
            <summary>
            Simple condition that exports unless the condition is meet
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.UnlessCondition.#ctor(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.UnlessCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenCondition">
            <summary>
            Simple condition true when delegate returns true
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenCondition.#ctor(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenDebuggerIsAttached">
            <summary>
            Export condition that limits the export to only be used when the debugger is attached
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenDebuggerIsAttached.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Returns true when the debugger is attached
            </summary>
            <param name="scope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenDebuggerIsNotAttached">
            <summary>
            Export condition that limits the export to only be used when there is no debugger
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenDebuggerIsNotAttached.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Returns true only when there is no debugger attached
            </summary>
            <param name="scope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenInjectedInto">
            <summary>
            Export condition that is true when being injected into
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="injectedType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenClassHas">
            <summary>
            Export condition that is true when class has a particular attribute on it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenMemberHas">
            <summary>
            Export condition that is true when the member (Constructor,Method or Property) has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenTargetHas">
            <summary>
            Export condition that is true when target has a particular attribute on it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportActivationDelegate">
            <summary>
            Delegate representing scope in wich this export is being activated
            </summary>
            <param name="injectionScope">scope that the export startegy is attached to, this can be different than it's owning scope</param>
            <param name="context">context for the injection</param>
            <returns>new activated object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Used to filter out exports
            </summary>
            <param name="context">context to use during filtering</param>
            <param name="strategy">strategy to filter</param>
            <returns>return true if the strategy should be used</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyComparer">
            <summary>
            Used to compare two exports within a particular export environment
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="exportEnvironment">current environment</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportRegistrationDelegate">
            <summary>
            This delegate allows you to provide extra registration during scope creation
            </summary>
            <param name="registration">registration object</param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportFunction`1">
            <summary>
            This delegate can be used to provide an export
            </summary>
            <typeparam name="T">type being returned</typeparam>
            <param name="injectionScope">injection scope</param>
            <param name="injectionContext">injection context</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.EnrichWithDelegate">
            <summary>
            Using this delegate you can provide custom logic to the activation process overriding 
            </summary>
            <param name="scope">injection scope for this export</param>
            <param name="injectionContext">injection context for this call</param>
            <param name="injectedObject">injected object</param>
            <returns>return the initial object or return a wrapping object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.BeforeDisposalCleanupDelegate">
            <summary>
            This delegate allows the developer to perform some cleanup before Dispose is called
            </summary>
            <param name="objectBeingDisposed"></param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportConditionDelegate">
            <summary>
            Delegate is used to figure out if the export strategy meets the proper condition
            </summary>
            <param name="scope">scope the export is in</param>
            <param name="injectionContext">injection context for this call</param>
            <param name="exportStrategy">export strategy being considered</param>
            <returns>return true if the export is to be considered</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportEnvironment">
            <summary>
            Defined what environement the application is running in or compenent is Exported in
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.Any">
            <summary>
            Can be used in any environment
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.RunTime">
            <summary>
            Best used at runtime
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.RunTimeOnly">
            <summary>
            Can only be used at runtime
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.DesignTime">
            <summary>
            Best used at design time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.DesignTimeOnly">
            <summary>
            Only used at design time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.UnitTest">
            <summary>
            Best used at unit test time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.UnitTestOnly">
            <summary>
            Only used at unit test time
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.DependencyLoopException">
            <summary>
            This exception is thrown when a loop is detected trying to resolve an export.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.ImportTypeMismatchException">
            <summary>
            Exception is thrown when there is a mismatch type when importing
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportsThat">
            <summary>
            static class that provides ExportStrategyFilter methods to be used during export registration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType">attribute type</param>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute">attribute type</typeparam>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace">namespace the type should be in</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type">class to check for</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T">class to check for</typeparam>
            <param name="includeSubnamespaces">include sub namespace</param>
            <returns>export configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyFilterGroup">
            <summary>
            A collection of export filters that can convert to one ExportStrategyFilter
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.#ctor(Grace.DependencyInjection.ExportStrategyFilter[])">
            <summary>
            Default Constructor
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.op_Implicit(Grace.DependencyInjection.ExportStrategyFilterGroup)~Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Converts export filter group to export strategy filter
            </summary>
            <param name="exportStrategyGroup"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.InternalExportStrategyFilter(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Internal filter method that loops through the collection of filters
            </summary>
            <param name="context">injection context</param>
            <param name="strategy">export strategy</param>
            <returns>true if the strategy matches</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocator">
            <summary>
            This interface can be used to locate an export. It's used by IInjectionScope and IDependencyInjectionContainer
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the container.
            </summary>
            <param name="newLocator">new secondary locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddStrategyInspector(Grace.DependencyInjection.IStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="registrationDelegate">registration delegate used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="configurationModule">configuration module used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="registrationDelegate">delegate used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope provider for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule">configuration module used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context
            </summary>
            <returns>new injection context</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext">injection context for the locate</param>
            <param name="consider">filter to be used when locating</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>export T if found, other wise default(T)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType">type to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating export</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName">name of export to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>List of T, this will return an empty list if not exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name">export name to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <returns>List of objects, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <returns>list of object, this will return an empty list if no exports are found</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocatorExtensions">
            <summary>
            Extension methods for IExportLocator
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``2(Grace.DependencyInjection.IExportLocator,``1,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type with a key
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <typeparam name="TKey">type of key</typeparam>
            <param name="locator">locator to use</param>
            <param name="key">key to use while locating</param>
            <param name="injectionContext">injection context to use</param>
            <param name="consider">filter method to use</param>
            <returns>export T</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``1(Grace.DependencyInjection.IExportLocator,System.String,``0,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name and key
            </summary>
            <typeparam name="TKey">key type</typeparam>
            <param name="locator">locator to use</param>
            <param name="exportName">name of export to locate</param>
            <param name="key">key to use during location</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter method</param>
            <returns>export object, null if no object found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``1(Grace.DependencyInjection.IExportLocator,System.Type,``0,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type and key
            </summary>
            <typeparam name="TKey">key type to locate</typeparam>
            <param name="locator">locator to use</param>
            <param name="exportType">type to locate</param>
            <param name="key">key to use while locating</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <returns>export object, null if no export found</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy">
            <summary>
            Closed generic strategy is used to create closed strategies by the generic strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy">
            <summary>
            This class exports a type using linq expressions
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExportStrategy">
            <summary>
            Represents an export strategy that can be configured to build a CompiledExportDelegate
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ConfigurableExportStrategy">
            <summary>
            This is the base export class, it provides method to configure itself
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IConfigurableExportStrategy">
            <summary>
            This interface is implemented by classes that can be configured for exporting
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategy">
            <summary>
            Classes that implement this interface can be used to export a particular type
            Note: All implementations of ExportStrategy should be thread safe. 
            It is expected that N number callers can activate at the same time.
            It's also recommended that the strategy me as immutable as possible
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportValueProvider">
            <summary>
            Classes that implement this interface can be used to provide an import value during construction
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportValueProvider.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext">injection context</param>
            <returns>true if the export should be used</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns>a list of strategies this export exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate">delegate called during activation</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.Lock">
            <summary>
            Lock the export from changing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetKey(System.Object)">
            <summary>
            Set the key value for the strategy
            </summary>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddExportName(System.String)">
            <summary>
            Add an export name for strategy
            </summary>
            <param name="exportName">new export name</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType">new type to export</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Set the export environment for the strategy
            </summary>
            <param name="environment">environment this export should be exported in</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetPriority(System.Int32)">
            <summary>
            Set the priority for the strategy
            </summary>
            <param name="priority">priority for the export</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetLifeCycleContainer(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Set the life cycle container for the strategy
            </summary>
            <param name="container">new lifecycle container for the export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Add a condition to the export
            </summary>
            <param name="exportCondition">export condition for strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddMetadata(System.String,System.Object)">
            <summary>
            Add metadata to export
            </summary>
            <param name="name">metadata name</param>
            <param name="value">metadata value</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Dispose">
            <summary>
            Dispose this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Lock">
            <summary>
            Locks the export for any more changes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetKey(System.Object)">
            <summary>
            Set the key value for the strategy
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddExportName(System.String)">
            <summary>
            Add an export name for strategy
            </summary>
            <param name="exportName"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Set the export environment for the strategy
            </summary>
            <param name="environment"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetPriority(System.Int32)">
            <summary>
            Set the priority for the strategy
            </summary>
            <param name="priority"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetLifeCycleContainer(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Set the life cycle container for the strategy
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Add a condition to the export
            </summary>
            <param name="exportCondition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddMetadata(System.String,System.Object)">
            <summary>
            Add metadata to the export
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Dispose(System.Boolean)">
            <summary>
            Dispose of this object
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ActivationType">
            <summary>
            Activation Type for this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Metadata">
            <summary>
            Metadata for export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ICompiledExportStrategy">
            <summary>
            This interface represents an export strategy that can be configured for importing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportMethod(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Configure the export to import a method
            </summary>
            <param name="methodInfo"></param>
            <param name="importValues"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportProperty(System.Reflection.PropertyInfo,System.String,System.Boolean,Grace.DependencyInjection.IExportValueProvider,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Configure the export to import a property
            </summary>
            <param name="propertyInfo"></param>
            <param name="exportName"></param>
            <param name="isRequired"></param>
            <param name="valueProvider"></param>
            <param name="exportStrategyFilter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ExportProperty(System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.String},Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            mark a property for exporting
            </summary>
            <param name="propertyInfo"></param>
            <param name="exportTypes"></param>
            <param name="exportNames"></param>
            <param name="exportCondition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Configure a method for activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Specify a particular constructor
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.WithCtorParam(Grace.DependencyInjection.IExportValueProvider,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="valueProvider"></param>
            <param name="argName"></param>
            <param name="argType"></param>
            <param name="exportStrategyFilter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds a cleanup delegate to export strategy
            </summary>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ICompiledExportStrategy.CreatingStrategy">
            <summary>
            When the strategy has been created by a generic strategy this will be set to the strategy that created it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportMethod(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Configure the export to import a method
            </summary>
            <param name="methodInfo"></param>
            <param name="importValues"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportProperty(System.Reflection.PropertyInfo,System.String,System.Boolean,Grace.DependencyInjection.IExportValueProvider,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Configure the export to import a property
            </summary>
            <param name="propertyInfo"></param>
            <param name="exportName"></param>
            <param name="isRequired"></param>
            <param name="valueProvider"></param>
            <param name="exportStrategyFilter"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Configure a method for activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Specify a particular constructor
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.WithCtorParam(Grace.DependencyInjection.IExportValueProvider,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="valueProvider">The value provider.</param>
            <param name="paramName">Name of the param.</param>
            <param name="paramType">Type of the param.</param>
            <param name="exportStrategyFilter">The export filter.</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds a cleanup delegate to export strategy
            </summary>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.GetCompiledInfo">
            <summary>
            Gets the CompiledExportDelegateInfo definition for this export
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExportStrategy.CreatingStrategy">
            <summary>
            When the strategy has been created by a generic strategy this will be set to the strategy that created it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.Equals(System.Object)">
            <summary>
            OVerride equals to compare if to closed generics are equal
            </summary>
            <param name="obj">object to compare</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.GetHashCode">
            <summary>
            Gets hashcode of activation name
            </summary>
            <returns>hash code value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate">
            <summary>
            THis class creates a compiled delegate that can be used for export
            It uses a function to create a new instance
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate">
            <summary>
            This class is used to create a delegate that creates an export and statisfies all it's imports
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.disposalExpressions">
            <summary>
            List of expressions for handling IDisposable
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.exportStrategyScopeParameter">
            <summary>
            The IInjectionScope parameter for the strategy
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.importInjectionContextExpressions">
            <summary>
            List of expressions that loacte the import from the injection context before resolving
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.injectionContextParameter">
            <summary>
            The IInjectionContext parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.instanceExpressions">
            <summary>
            List of expressions used to construct the instance
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.instanceVariable">
            <summary>
            Variable that represents the instance being constructed
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.isRequiredExpressions">
            <summary>
            List of expressions that test if an import is null
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CompileDelegate">
            <summary>
            Compiles the export delegate
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.GenerateDelegate">
            <summary>
            This method generates the compiled delegate
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.SetUpParameterExpressions">
            <summary>
            Sets up the parameters for the delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.SetUpInstanceVariableExpression">
            <summary>
            Sets up a local variable that hold the instance that will be injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateInstantiationExpression">
            <summary>
            This method creates the expression that calls the constructor or function to create a new isntance that will be returned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateCustomInitializeExpressions">
            <summary>
            This method creates expressions that call Initialization methods (i.e. methods that take IInjectionContext and are called after
            construction and before properties are injected)
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreatePropertyImportExpressions">
            <summary>
            Creates all the import expressions for properties that are being injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateMethodImportExpressions">
            <summary>
            Creates all method import expressions for the export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateActivationMethodExpressions">
            <summary>
            Create all the expressions for activatition methods
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateDisposableMethodExpression">
            <summary>
            Create expressions for disposable objects
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateEnrichmentExpression">
            <summary>
            
            </summary>
            <returns>true if there was an enrichment expression created</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.ExecuteEnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object)">
            <summary>
            This method is used to execute an EnrichWithDelegate
            </summary>
            <param name="enrichWithDelegate"></param>
            <param name="scope"></param>
            <param name="context"></param>
            <param name="injectObject"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateReturnExpression">
            <summary>
            Creates a return expression 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateImportExpression(System.Type,Grace.DependencyInjection.IInjectionTargetInfo,System.String,System.String,System.Boolean,Grace.DependencyInjection.IExportValueProvider,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a local variable an then tries to import the value
            </summary>
            <param name="importType"></param>
            <param name="targetInfo"></param>
            <param name="exportName"></param>
            <param name="variableName"></param>
            <param name="isRequired"></param>
            <param name="valueProvider"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFunc``1(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new Func(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionScope"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFuncWithContext``1(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new Func(IInjectionContext,T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionScope"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateOwned``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new Owned(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateLazy``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Create a new Lazy(T) 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="exportStrategyFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="activationDelegate"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.CreateInstantiationExpression">
            <summary>
            This method creates the expression that calls the constructor or function to create a new isntance that will be returned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.InvokeActivationDelegate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method used to invoke an activation delegate
            </summary>
            <param name="exportStrategyScope"></param>
            <param name="activationDelegate"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.InjectionTargetExtraDataKey">
            <summary>
            Extra Data Key for Injection Target
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.LocateInjectionObject(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Returns the injection target
            </summary>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.AttributeExportStrategy">
            <summary>
            Exports a type using attributes to define how it should be exported
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributeExportStrategy.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            DEfault constructor
            </summary>
            <param name="exportType"></param>
            <param name="attributes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributeExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2">
            <summary>
            Creates a new instance of any class that implements ICollection(TItem)
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Equals(System.Object)">
            <summary>
            Override to compare 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.GetHashCode">
            <summary>
            Overriding because I'm overriding equals
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.ExportNames">
            <summary>
            Export names for this collection
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1">
            <summary>
            This strategy takes a func and calls it when ever
            </summary>
            <typeparam name="T">type of instance that will be exported</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.#ctor(Grace.DependencyInjection.ExportFunction{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="instanceFunc">export func</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope">export injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">export strategy filter</param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.InternalActivate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            internal activate method
            </summary>
            <param name="injectionscope">injection scope</param>
            <param name="context">injection context</param>
            <returns>export instance</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PropertyExportStrategy">
            <summary>
            Property Export exports a property from another IExportStrategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.#ctor(System.Reflection.PropertyInfo,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Default constructor
            </summary>
            <param name="property"></param>
            <param name="targetStrategy"></param>
            <param name="exportCondition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            If this strategy meets condition and the target target strategy meets condition
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.BuildAccessor">
            <summary>
            Builds an accessor method 
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IStrategyInspector">
            <summary>
            Classes that implement this interface can be used to inspect strategies as they are being added to the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IStrategyInspector.StrategyInitializing(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called everytime a strategy about to be added to the the IInjectionScope
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportsThatConfiguration">
            <summary>
            Configuration for ExportsThat, build a 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType">attribute type</param>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute">attribute type</typeparam>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace">namespace the type should be in</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type">class to check for</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T">class to check for</typeparam>
            <param name="includeSubnamespaces">include sub namespace</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.op_Implicit(Grace.DependencyInjection.Impl.ExportsThatConfiguration)~Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Converts the configuration to a filter automatically
            </summary>
            <param name="configuration">configuration object</param>
            <returns>new filter method</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IMissingExportHandler">
            <summary>
            This interface is an internal interface that is used to tell the scope that there is a missing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IMissingExportHandler.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate missing exports
            </summary>
            <param name="context">injection context</param>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="consider">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator">
            <summary>
            This class is a simple secondary resolver implementation
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ISecondaryExportLocator">
            <summary>
            Classes that wish to participate in resolving unknown exports can implement this interface.
            If an export can't be located in a scope a secondary dependency resolvers will be called
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate will be called when the injection scope can't locate a particular resource
            </summary>
            <param name="owningScope">the scope that the locate came through</param>
            <param name="context">injection context for the locate</param>
            <param name="resolveName">name being resolved</param>
            <param name="resolveType">type being resolved</param>
            <param name="consider">filter to use while resolving</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.LocateAll(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            LocateAll will be called every time a collection is resolved
            </summary>
            <param name="owningScope">the scope that the locate came through</param>
            <param name="context">injection context for the locate</param>
            <param name="resolveName">name of the export being resolved</param>
            <param name="resolveType">type that is being resolved</param>
            <param name="collectionEmpty">value saying if there are already values in the collection</param>
            <param name="consider">filter to use while locating</param>
            <returns>list of exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Default constructor
            </summary>
            <param name="initValues"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Resolve will be called when the injection scope can't locate a particular resource
            </summary>
            <param name="owningScope"></param>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.LocateAll(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            ResolveAll will be called every time a collection is resolved
            </summary>
            <param name="owningScope"></param>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="collectionEmpty"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(System.Func{``0})">
            <summary>
            Adds a value to the resolver
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue(System.String,System.Object)">
            <summary>
            Adds a resolve value but name
            </summary>
            <param name="resolveName"></param>
            <param name="resolveValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(System.String,System.Func{``0})">
            <summary>
            Adds a value to the resolver
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveName"></param>
            <param name="resolveFunc"></param>
        </member>
        <member name="T:Grace.DependencyInjection.IConfigurationModule">
            <summary>
            Classes that implement this method can be used to configure a registration scope or container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurationModule.Configure(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Called by the injection scope to add exports to the scope
            </summary>
            <param name="registrationBlock"></param>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScopeProvider">
            <summary>
            Provides disposal scopes for an IInjectionScope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScopeProvider.ProvideDisposalScope">
            <summary>
            Provides a default disposal scope, otherwise the current IInjectionScope will be used
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1">
            <summary>
            This interface allows you to configure an instance for export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as a particular interface
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if the Property or method or constructor is attribute with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportRegistrationBlock">
            <summary>
            This interface allows you to register exports.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Type)">
            <summary>
            Register an export by it's type. This is required when dealing with open generics
            </summary>
            <param name="type">type to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export``1">
            <summary>
            Export a class by it's type. This method allows you to specify things using linq expressions
            </summary>
            <typeparam name="T">type to export</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Export a collection of types all at one time
            </summary>
            <param name="types">collection of types to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly for exports.
            </summary>
            <param name="assembly">assembly to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Register a set of assemblies.
            </summary>
            <param name="assemblies">list of assemblies to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T">instance type</typeparam>
            <param name="instance">instance to export</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunction">Func that creates instance</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFunc``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export function
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="exportFunction">Function to create instance of T</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddExportStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy directly to a scope
            </summary>
            <param name="strategy">new startegy</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IDependencyInjectionContainer">
            <summary>
            This interface defines the base functionality for the container
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScope">
            <summary>
            Defines a scope for injection that will dispose any objects added to it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add an object for disposal 
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove an object from the disposal scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.BlackListExport(System.String)">
            <summary>
            Black lists a particular export (Fullname)
            </summary>
            <param name="exportType">full name of type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.BlackListExportType(System.Type)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType">type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="registrationDelegate">delegate to be used to configure the scope</param>
            <param name="scopeName">scope name to configure</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="configurationModule">configuration module object to be used configure the scope</param>
            <param name="scopeName">name of scope to configure</param>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.AutoRegisterUnknown">
            <summary>
            If a concrete type is requested and it is not registered an export strategy will be created.
            Note: It will be scanned for attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.ThrowExceptions">
            <summary>
            If true exception will be thrown if a type can't be located, otherwise it will be caught and errors logged
            False by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.RootScope">
            <summary>
            The root scope for the container
            </summary>
        </member>
        <member name="E:Grace.DependencyInjection.IDependencyInjectionContainer.ResolveUnknownExports">
            <summary>
            Handling this event allows you to add exports to the container when an export can't be located.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetConfiguration">
            <summary>
            Allows you to configure an assembly for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExportInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>returns self</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExportInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExportTypesBasedOn(System.Type)">
            <summary>
            Export all types based on speficied type
            </summary>
            <param name="baseType">base type to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithPriority(System.Int32)">
            <summary>
            Export with the spcified priority
            </summary>
            <param name="priority">priority to export at</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export in the specified Environment
            </summary>
            <param name="environment">environment to export in</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndWeakSingleton">
            <summary>
            Exports are to be marked as shared, similar to a singleton only using a weak reference.
            It can not be of type IDisposable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndSingleton">
            <summary>
            Export services as Singletons
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithLifeCycle(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Set a particular life cycle 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export all attributed types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Select(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to filter out types based on the provided where clause
            </summary>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategyCollection">
            <summary>
            Represents a collection of export strategies for a particular export name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.ActivateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate all instances of a type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="injectionContext">injection context</param>
            <param name="filter">export filter</param>
            <returns>list of exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.Activate(System.String,System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the first export strategy that meets conditions
            </summary>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="injectionContext">injection context</param>
            <param name="filter">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.AddExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy to the collection
            </summary>
            <param name="exportStrategy">new export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.RemoveExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Remove an export strategy from the collection
            </summary>
            <param name="exportStrategy">old export strategy</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategyCollection.ExportStrategies">
            <summary>
            A enumerable of export strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration">
            <summary>
            This inteface allows you to configure an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportProperty(System.String,System.Boolean,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="propertyName">name of property to import</param>
            <param name="isRequired">is the property required</param>
            <param name="exportName">name of the export to import</param>
            <param name="consider">export filter to use while importing</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportProperty``1(System.String,System.Func{Grace.DependencyInjection.IInjectionContext,``0},System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for import and provide an IExportActivator to resolve it
            </summary>
            <param name="propertyName">name of property to import</param>
            <param name="exportActivator">allows you to provide a value</param>
            <param name="isRequired">is the property required</param>
            <param name="consider">export filter to use while importing</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportProperty(System.String,Grace.DependencyInjection.IExportValueProvider,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for import and provide an IExportActivator to resolve it
            </summary>
            <param name="propertyName">name of property to import</param>
            <param name="valueProvider">allows you to provide a vlue</param>
            <param name="isRequired">is the property required</param>
            <param name="consider">export filter to use while importing</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportMethod(System.String,System.Object)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="methodName">name of method to import</param>
            <param name="defaultParameters">default parameters</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExportProperty(System.String,System.Type[])">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName">name of property to export</param>
            <param name="exportTypes">types to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExportProperty(System.String,System.String,System.String[])">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName">name of property to export</param>
            <param name="exportName">name to export under</param>
            <param name="exportNames">names to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExportPropertyWithCondition(System.String,Grace.DependencyInjection.Conditions.IExportCondition,System.Type[])">
            <summary>
            Export a specific property under a particular and condition
            </summary>
            <param name="propertyName">name of property to export</param>
            <param name="condition">condition to export under</param>
            <param name="exportTypes">types to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExportPropertyWithCondition(System.String,Grace.DependencyInjection.Conditions.IExportCondition,System.String,System.String[])">
            <summary>
            Export a specific property under a particular and condition
            </summary>
            <param name="propertyName">property name to export</param>
            <param name="condition">condition to export the property under</param>
            <param name="exportName">names to export under</param>
            <param name="exportNames">more names to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod">name of method to activate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.UsingLifeCycleContainer(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Specify a custom lifecycle container for export.
            </summary>
            <param name="container">lifecycle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            Note: Only public writeable properties will be imported
            </summary>
            <param name="required">are all the properties required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam``1(``0,System.String)">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching it used</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0},System.String)">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching it used</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam``1(Grace.DependencyInjection.IExportValueProvider,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value provider for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching it used</param>
            <param name="consider">export filter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1">
            <summary>
            This interface allows you to configure an export strategy for type T
            </summary>
            <typeparam name="T">type to export</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithKey(System.Object)">
            <summary>
            Attach a key to the export
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <param name="property">property expression (x => x.PropertyName) </param>
            <param name="isRequired">is the import required (object will not construct if true and cannot be found)</param>
            <param name="exportName">export name to use (when null it will use the property type to locate the export)</param>
            <param name="consider">provide an ImportFilter that will be used to filter exports</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{Grace.DependencyInjection.IInjectionContext,``0},System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for Import and provide the export for it
            </summary>
            <param name="property"></param>
            <param name="propertyFunc"></param>
            <param name="isRequired"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},Grace.DependencyInjection.IExportValueProvider,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for Import and provide the export for it
            </summary>
            <param name="property"></param>
            <param name="valueProvider"></param>
            <param name="isRequired"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Type[])">
            <summary>
            Export a property to be imported by other exports
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,System.String[])">
            <summary>
            Export a property by name
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <param name="exportName"></param>
            <param name="exportNames"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}},System.Object)">
            <summary>
            Mark a method to be called upon activation passing in an arguement that has be located using the IoC
            </summary>
            <param name="method">method to import</param>
            <param name="parameterDefaults">an object that can be used to specify default parameters</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.UsingLifeCycleContainer(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``1(``0,System.String)">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching is used</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0},System.String)">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching is used</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``1(Grace.DependencyInjection.IExportValueProvider,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value provider for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching is used</param>
            <param name="consider">filter which export to use</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionContext">
            <summary>
            There is one new Injection context object created for each injection request.
            It holds information pertinent to this injection
            Note: The implementation for IInjectionContext is not thread safe
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Locate``1">
            <summary>
            Locate an export by type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Locate(System.String)">
            <summary>
            Locate an export by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.RegisterExport``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export by type for this injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.RegisterExport(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Register an export by name for this injection context
            </summary>
            <param name="name"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.IncrementResolveDepth">
            <summary>
            Increment the resolve depth by one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.DecrementResolveDepth">
            <summary>
            Decrement the resolve depth by one
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.DisposalScope">
            <summary>
            The disposal scope associated with this injection request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.RequestingScope">
            <summary>
            The scope that the request originated in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.TargetInfo">
            <summary>
            The target information for the current injection, 
            specifically what is the type you are being injected into and what is the PropertyInfo or ParameterInfo being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.MaxResolveDepth">
            <summary>
            Max resolve depth allowed
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionScope">
            <summary>
            IInjectionScope represents a scope for injection that can be created and inherited from at any time
            Note: The implementation for IInjectionScope is thread safe. 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.ChildScopes">
            <summary>
            Gets an enumeration of child scopes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.GetStrategyCollection(System.String)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportName"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionScope.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.Container">
            <summary>
            The container this scope was created in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ScopeId">
            <summary>
            Unique identifier for the instance of the injection scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ScopeName">
            <summary>
            The scopes name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ParentScope">
            <summary>
            Parent scope, can be null if it's the root scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionTargetInfo">
            <summary>
            Defines properties that are specific to the property that is being imported
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTypeAttributes">
            <summary>
            These are the attributes for the class that it's being injected into
            Null if it's the root object in the dependency graph
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetName">
            <summary>
            This is the property or parameter name being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetType">
            <summary>
            This the type for the Property or Parameter being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionMemberAttributes">
            <summary>
            Attributes on the Constructor, Method, or Property being injected
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ArrayExportStrategy`1">
            <summary>
            Creates a new array export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the array
            </summary>
            <param name="exportInjectionScope">injection scope that this activation is associated with</param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Equals(System.Object)">
            <summary>
            Overriding equals so multiple instances of Array
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.GetHashCode">
            <summary>
            Gets the hashcode for the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IExportStrategyProvider">
            <summary>
            Used by classes that provide strategies to the registration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IExportStrategyProvider.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo">
            <summary>
            Represents the information needed to build a compiled delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.AddConstructorParamInfo(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds a constructor parameter info
            </summary>
            <param name="paramInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Imports a property for the export
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Mark a method for importing 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Mark a method to be called during activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Add an enrich with delegate to the strategy
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.SetImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Sets the constructor info for the export
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds new cleanup delegate 
            </summary>
            <param name="newCleanupDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.Attributes">
            <summary>
            Attributes associated with the export type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.IsTransient">
            <summary>
            Is this export transient
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.TrackDisposable">
            <summary>
            Track the export if disposable
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivationType">
            <summary>
            This is the type that is being activated can be interface
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.CleanupDelegate">
            <summary>
            
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportProperties">
            <summary>
            List of properties to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportMethods">
            <summary>
            List of methods to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportConstructor">
            <summary>
            Constructor to use for importing, can be null
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ConstructorParams">
            <summary>
            List of constructor arguements
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivationMethodInfos">
            <summary>
            List of activation methods 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichmentDelegates">
            <summary>
            List of enrichment delegates to apply to the export
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo">
            <summary>
            Information on how to import a method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.MethodToImport">
            <summary>
            Import the method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.ImportValuesObject">
            <summary>
            Object that contains value to be used during importing
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo">
            <summary>
            Information on how to import a property
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ImportName">
            <summary>
            Import name to use if not importing by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.Property">
            <summary>
            Property to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ValueProvider">
            <summary>
            Value provider for the import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ExportStrategyFilter">
            <summary>
            Export filter associated with this import
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo">
            <summary>
            Information about a constructor arguement
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ParameterName">
            <summary>
            Name of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ParameterType">
            <summary>
            Type of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ImportName">
            <summary>
            Import name to use if not importing by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ValueProvider">
            <summary>
            The value provider
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ExportStrategyFilter">
            <summary>
            Export filter associated with this import
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.BlackList">
            <summary>
            Represents a list of exports that should be black listed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.GetEnumerator">
            <summary>
            returns a list of class names that are black listed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.Add(System.String)">
            <summary>
            adds a new name to the black list
            </summary>
            <param name="blackedOut"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.Add(System.Type)">
            <summary>
            Add a new type to black list
            </summary>
            <param name="blackOutType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.IsExportStrategyBlackedOut(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Checks to see if an export strategy is on the black list.
            </summary>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate">
            <summary>
            This class compiles a delegate to be used for exporting. 
            It creates a new instance using the types constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate.PickConstructor(System.Type)">
            <summary>
            Picks the specific constructor to use for exporting
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1">
            <summary>
            This export takes an activation delegate and creates a linq compiled expression
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.#ctor(Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="exportActivationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DisposalScope">
            <summary>
            Represents a disposal scope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope.disposed">
            <summary>
            true if the object has already been disposed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.Dispose">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add and object to the scope for disposal
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove the object from the scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.Dispose(System.Boolean)">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.TrackedDisposables">
            <summary>
            Returns a list of all objects being tracked
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException">
            <summary>
            This exception is thrown when an IDisposable object is requested and no disposal scope is present.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="activationType"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration">
            <summary>
            Exports a set of types based on a provided configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.#ctor(Grace.DependencyInjection.IInjectionScope,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionScope"></param>
            <param name="scanTypes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExportInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>returns self</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExportInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="filterMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExportTypesBasedOn(System.Type)">
            <summary>
            Export all types based on speficied type
            </summary>
            <param name="baseType">base type to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithPriority(System.Int32)">
            <summary>
            Export with the spcified priority
            </summary>
            <param name="priority">priority to export at</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export in the specified Environment
            </summary>
            <param name="environment">environment to export in</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndWeakSingleton">
            <summary>
            Exports are to be marked as shared, similar to a singleton only using a weak reference.
            It can not be of type IDisposable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndSingleton">
            <summary>
            Export services as Singletons
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithLifeCycle(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Set a particular life cycle 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export all attributed types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Select(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to filter out types based on the provided where clause
            </summary>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1">
            <summary>
            Configures an instance for export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.#ctor(System.Type,Grace.DependencyInjection.Impl.IConfigurableExportStrategy)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportType"></param>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as a particular interface
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if the Property or method or constructor is attribute with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportRegistrationBlock">
            <summary>
            This class implements the IExportRegistrationBlock interface and provides exports for IInjectionScope
            Note: this class is not thread safe. You can call configure from multiple threads on the same scope
            but you can not call from multiple threads to the same instance of a registration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Type)">
            <summary>
            Register an export by it's type. This is required when dealing with open generics
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export``1">
            <summary>
            Register an export by it's type. This method allows you to specify things using linq expressions
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Register a collection of types all at one time
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly for exports. You can perform any of these
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Register a set of assemblies.
            </summary>
            <param name="assemblies"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFunc``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export function
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddExportStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy directly to a scope
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetExportStrategies">
            <summary>
            Get all exports for the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.FilterOutBasedOnEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Filter out strategies that are exported for particular environments
            </summary>
            <param name="strategyEnvironment"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportStrategyListProvider">
            <summary>
            List of export strategies that can act as a IExportStrategyProvider
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyListProvider.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration">
            <summary>
            This class allows you to configure a type for exporting using fluent syntax
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.#ctor(System.Type,Grace.DependencyInjection.Impl.ICompiledExportStrategy)">
            <summary>
            
            </summary>
            <param name="exportType"></param>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportProperty(System.String,System.Boolean,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="propertyName"></param>
            <param name="isRequired"></param>
            <param name="exportName"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportProperty``1(System.String,System.Func{Grace.DependencyInjection.IInjectionContext,``0},System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for import and provide an IExportActivator to resolve it
            </summary>
            <param name="propertyName"></param>
            <param name="exportActivator">allows you to provide a value</param>
            <param name="isRequired">is the property required</param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportProperty(System.String,Grace.DependencyInjection.IExportValueProvider,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for import and provide an IExportActivator to resolve it
            </summary>
            <param name="propertyName"></param>
            <param name="valueProvider">allows you to provide a vlue</param>
            <param name="isRequired">is the property required</param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportMethod(System.String,System.Object)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="methodName"></param>
            <param name="defaultParameters"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ExportProperty(System.String,System.Type[])">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName"></param>
            <param name="exportTypes"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ExportProperty(System.String,System.String,System.String[])">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName"></param>
            <param name="exportName"></param>
            <param name="exportNames"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.UsingLifeCycleContainer(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Specify a custom lifecycle container for export.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            </summary>
            <param name="required"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam``1(``0,System.String)">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching it used</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0},System.String)">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching it used</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam``1(Grace.DependencyInjection.IExportValueProvider,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value provider for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching it used</param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1">
            <summary>
            This class configures a particular type for export using fluent syntax
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.#ctor(Grace.DependencyInjection.Impl.ICompiledExportStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithKey(System.Object)">
            <summary>
            Export under a specific key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( x => new MyTypeName("Specific","Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( x => new MyTypeName("Specific","Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <param name="property">property expression (x => x.PropertyName) </param>
            <param name="isRequired">is the import required (object will not construct if true and cannot be found)</param>
            <param name="exportName">export name to use (when null it will use the property type to locate the export)</param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Func{Grace.DependencyInjection.IInjectionContext,``0},System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for Import and provide the export for it
            </summary>
            <param name="property"></param>
            <param name="propertyFunc"></param>
            <param name="isRequired"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},Grace.DependencyInjection.IExportValueProvider,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Mark a property for Import and provide the export for it
            </summary>
            <param name="property"></param>
            <param name="valueProvider"></param>
            <param name="isRequired"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Type[])">
            <summary>
            Export a property to be imported by other exports
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,System.String[])">
            <summary>
            Export a property by name
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <param name="exportName"></param>
            <param name="exportNames"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}},System.Object)">
            <summary>
            Mark a method to be called upon activation passing in an arguement that has be located using the IoC
            </summary>
            <param name="method"></param>
            <param name="defaultParameters"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.UsingLifeCycleContainer(Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``1(``0,System.String)">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching is used</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0},System.String)">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching is used</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``1(Grace.DependencyInjection.IExportValueProvider,System.String,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">value provider for the parameter</param>
            <param name="paramName">name of the parameter, if null type matching is used</param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncExportStrategy`1">
            <summary>
            This export strategy creates a new Func(T) that calls the current scope 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Dispose">
            <summary>
            Dispose the func export, nothing to do
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncValueProvider`1">
            <summary>
            A value provider that calls a func to generate it's export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncValueProvider`1.#ctor(System.Func{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncValueProvider`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1">
            <summary>
            A value provider that calls a func to generate it's export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1.#ctor(System.Func{Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2">
            <summary>
            Export strategy that creates a Func(TIn, TOut)
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`2.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3">
            <summary>
            Export strategy that creates Func(TIn1, TIn2, Tout)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Dispose">
            <summary>
            Dispose the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`3.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4">
            <summary>
            Export strategy that creates a Func(TIn1, Tin2, TIn3, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`4.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5">
            <summary>
            Creates a new Func(TIn1, TIn2, TIn3, TIn4, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TIn4"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`5.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6">
            <summary>
            Creates a new Func(TIn1, TIn2, TIn3, TIn4, TIn5, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TIn4"></typeparam>
            <typeparam name="TIn5"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Dispose">
            <summary>
            Dispose the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericFuncExportStrategy`6.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericExportStrategy">
            <summary>
            Represents a generic export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.CheckGenericConstrataints(System.Type[])">
            <summary>
            Checks to make sure the closing types meet generic constraints
            </summary>
            <param name="closingTypes"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.CreateClosedStrategy(System.Type[])">
            <summary>
            Creates a new closed export strategy that can be activated
            </summary>
            <param name="closingTypes"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.GenericExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionTargetInfo">
            <summary>
            Represents the information about injecting a particular object into another
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionTargetInfo.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Attribute},System.Object,System.Collections.Generic.IEnumerable{System.Attribute},System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType">the type that is being injected into</param>
            <param name="injectionTypeAttributes">attributes on the type being injected</param>
            <param name="injectionTarget">the ParameterInfo or PropertyInfo being injected into</param>
            <param name="injectionTargetAttributes">attributes on the ParameterInfo or PropertyInfo</param>
            <param name="injectionMemberAttributes">attribute on the Method,Constructor, or Property</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTypeAttributes">
            <summary>
            These are the attributes for the class that it's being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetName">
            <summary>
            This is the property or parameter name being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetType">
            <summary>
            This the type for the Property or Parameter being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionMemberAttributes">
            <summary>
            Attributes associated with Constructor, Property or Method that is being injected
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategy`1">
            <summary>
            Instance strategy represents the export strategy for a particular export instance
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategy`1.#ctor(`0)">
            <summary>
            Default Constructor
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Return the instance
            </summary>
            <param name="exportInjectionScope">injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.RootScopeCloneException">
            <summary>
            This exception is thrown when you attempt to clone an InjectionKernel that doesn't have a parent
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.RootScopeCloneException.#ctor(System.String,System.Guid)">
            <summary>
            Default Constructor
            </summary>
            <param name="scopeName"></param>
            <param name="scopeId"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.LazyExportStrategy`1">
            <summary>
            Export strategy creates a new Lazy(T)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Dispose">
            <summary>
            Dipose the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Equals(System.Object)">
            <summary>
            Override equals 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.GetHashCode">
            <summary>
            Override because of equals override
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ListExportStrategy`1">
            <summary>
            Export Strategy for creating List(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Dispose">
            <summary>
            Dispose the Export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.OwnedStrategy`1">
            <summary>
            An export strategy for creating Owned(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1">
            <summary>
            Export strategy to create ReadOnlyCollection(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Dispose">
            <summary>
            Dispose strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.SecondaryStrategies">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Equals(System.Object)">
            <summary>
            Override equals to check if the export strategy is the same
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.GetHashCode">
            <summary>
            Override because of equals override
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.LifeCycleContainer">
            <summary>
            ILifeCycleContainer associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer">
            <summary>
            ILifeCycleContainer objects are used to manage the lifecycle of a particular export
            Singleton, Shared, Cached, and PerRequest are examples of lifecycle containers
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer.Clone">
            <summary>
            This method is used to clone a lifecycle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.LifeCycleContainers.ILifeCycleContainer.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.DependencyInjectionContainer">
            <summary>
            This is the standard IDependencyInjectionContainer implementation
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.#ctor(Grace.DependencyInjection.ExportEnvironment,Grace.DependencyInjection.ExportStrategyComparer,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Default Constructor
            </summary>
            <param name="environment">Environment that you want this container to operate in (RunTime, DesignTime, Or UnitTest</param>
            <param name="comparer">delegate that can be used to sort exports, if null is provided CompareExportStrategies will be used</param>
            <param name="disposalScopeProvider">allows you to provide a custom disposal scope provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.BlackListExport(System.String)">
            <summary>
            Black lists a particular export (Fullname)
            </summary>
            <param name="exportType">full name of the type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.BlackListExportType(System.Type)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType">type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the container.
            </summary>
            <param name="newLocator">new secondary locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddStrategyInspector(Grace.DependencyInjection.IStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="registrationDelegate">configuration delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="configurationModule"></param>
            <param name="scopeName"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add an object for disposal 
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove an object from the disposal scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="registrationDelegate"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="configurationModule"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="scopeName">the name of the scope that is being configured</param>
            <param name="registrationDelegate">configuration delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext">injection context for the locate</param>
            <param name="consider">filter to be used when locating</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>export T if found, other wise default(T)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType">type to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating export</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName">name of export to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>List of T, this will return an empty list if not exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name">export name to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <returns>List of objects, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <returns>list of object, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Dispose">
            <summary>
            Dispose of the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate missing exports
            </summary>
            <param name="context">injection context</param>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="consider">export filter</param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CompareExportStrategies(Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            This method compares 2 export strategies in a particular environment using ExportEnvironment attributes and ExportPriority attributes
            </summary>
            <param name="x">x compare object</param>
            <param name="y">y compare object</param>
            <param name="environment">environment to compare the strategies in</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Dispose(System.Boolean)">
            <summary>
            dispose implementation
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.AutoRegisterUnknown">
            <summary>
            If a concrete type is requested and it is not registered an export strategy will be created.
            Note: It will be scanned for attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.ThrowExceptions">
            <summary>
            If true exception will be thrown if a type can't be located, otherwise it will be caught and errors logged
            False by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.RootScope">
            <summary>
            The root scope for the container
            </summary>
        </member>
        <member name="E:Grace.DependencyInjection.DependencyInjectionContainer.ResolveUnknownExports">
            <summary>
            By handling this event you can provide a value when no export was found
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportStrategyCollection">
            <summary>
            A collection of exports to be used for dependency resolution
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportEnvironment,Grace.DependencyInjection.ExportStrategyComparer)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionKernel"></param>
            <param name="environment"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Activate(System.String,System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate the first export strategy that meets conditions
            </summary>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.ActivateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Activate all instances of a type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.AddExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy to the collection
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.RemoveExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Remove an export strategy from the collection
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Dispose">
            <summary>
            Dispose this collection of strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Dispose(System.Boolean)">
            <summary>
            Dispose this collection strategies
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Clone(Grace.DependencyInjection.Impl.InjectionKernel)">
            <summary>
            Clone the collection
            </summary>
            <param name="injectionKernel"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportStrategyCollection.ExportStrategies">
            <summary>
            A enumerable of export strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionKernel">
            <summary>
            InjectionKernel keeps a collection of exports to be used for resolving dependencies.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.#ctor(Grace.DependencyInjection.Impl.InjectionKernelManager,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IDisposalScopeProvider,System.String,Grace.DependencyInjection.ExportStrategyComparer)">
            <summary>
            Default constructor
            </summary>
            <param name="kernelManager">kernel manager for this kernel</param>
            <param name="parentScope"></param>
            <param name="scopeProvider">passing a null for scope provider is ok</param>
            <param name="scopeName"></param>
            <param name="comparer"></param>	
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.ChildScopes">
            <summary>
            Gets an enumeration of child scopes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName"></param>
            <param name="registrationDelegate"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the injection scope
            </summary>
            <param name="newLocator"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Clone(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IDisposalScopeProvider,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Clone the injection kernel, the rootscope cannot be cloned
            </summary>
            <param name="parentScope"></param>
            <param name="parentScopeProvider"></param>
            <param name="scopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            You can add extra configuration to the scope
            </summary>
            <param name="registrationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Configure the scope with a configuration module
            </summary>
            <param name="configurationModule"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context associated with this scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategyCollection(System.String)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportName"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate missing exports, this is an internal method
            </summary>
            <param name="context"></param>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Dispose(System.Boolean)">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.Container">
            <summary>
            The container this scope was created in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ScopeId">
            <summary>
            Unique identifier for the instance of the injection scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ScopeName">
            <summary>
            The scopes name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ParentScope">
            <summary>
            Parent scope, can be null if it's the root scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionKernelManager">
            <summary>
            This class creates all injection kernels and contains all the configuration for all kernels
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.#ctor(Grace.DependencyInjection.DependencyInjectionContainer,Grace.DependencyInjection.ExportStrategyComparer,Grace.DependencyInjection.Impl.BlackList)">
            <summary>
            Default constructor
            </summary>
            <param name="container">container for the kernel manager</param>
            <param name="comparer">used to compare to export strategies for which one should be used</param>
            <param name="blackList">export strategy black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.SetRootScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            This method must be called before you configure any named kernels
            </summary>
            <param name="newRootScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            Allows you to configure a base kernel of a particular name
            </summary>
            <param name="kernelName">name of the kernel being configured</param>
            <param name="registrationDelegate">registration delegate to call configure with</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.CreateNewKernel(Grace.DependencyInjection.Impl.InjectionKernel,System.String,Grace.DependencyInjection.ExportRegistrationDelegate,Grace.DependencyInjection.IDisposalScopeProvider,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Create a new Kernel of a particular name
            </summary>
            <param name="parentKernel">the parent kernel</param>
            <param name="kernelName">name of the kernel to create</param>
            <param name="registrationDelegate"></param>
            <param name="parentScopeProvider"></param>
            <param name="scopeProvider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernelManager.BlackList">
            <summary>
            Black list associated with this kernel manager
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernelManager.Container">
            <summary>
            Container this kernel manager is associated with
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionContext">
            <summary>
            Default implementation of IInjectionContext
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.#ctor(Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="disposalScope"></param>
            <param name="requestingScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Locate``1">
            <summary>
            Locate an export by type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Locate(System.String)">
            <summary>
            Locate an export by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.RegisterExport``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export by type for this injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.RegisterExport(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Register an export by name for this injection context
            </summary>
            <param name="name"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.IncrementResolveDepth">
            <summary>
            Increment the resolve depth by one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.DecrementResolveDepth">
            <summary>
            Decrement the resolve depth by one
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.DisposalScope">
            <summary>
            Disposal scope for the injection context
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.RequestingScope">
            <summary>
            The scope that the request originated in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.TargetInfo">
            <summary>
            The target information for the current injection
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.MaxResolveDepth">
            <summary>
            Max resolve depth allowed
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.IPerRequestLifeCycleContainerProvider">
            <summary>
            This interface is used by the SingletonPerRequestContainer
            It is used to provide a per request lifecycle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.IPerRequestLifeCycleContainerProvider.ProvideContainer">
            <summary>
            Called to provide a new per request lifecycle container
            </summary>
            <returns>new lifecycle container</returns>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.SingletonPerInjectionContextContainer">
            <summary>
            Exports that use this will be shared per injection context and are considered transient
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerInjectionContextContainer.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerInjectionContextContainer.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerInjectionContextContainer.Clone">
            <summary>
            This method is used to clone a lifecycle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.LifeCycleContainers.SingletonPerInjectionContextContainer.Transient">
            <summary>
            Always true
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.SingletonPerRequestContainer">
            <summary>
            Exports that use this will be shared per request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerRequestContainer.Dispose">
            <summary>
            Dispose the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerRequestContainer.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerRequestContainer.Clone">
            <summary>
            This method is used to clone a lifecycle container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerRequestContainer.LocateContainer(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locates an ILifeCycleContainer
            </summary>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.LifeCycleContainers.SingletonPerRequestContainer.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.SingletonPerScopeContainer">
            <summary>
            This lifecycle container will create an instance per scope instance.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerScopeContainer.Dispose">
            <summary>
            Dispose this lifecycle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerScopeContainer.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonPerScopeContainer.Clone">
            <summary>
            This method is used to clone a lifecycle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.LifeCycleContainers.SingletonPerScopeContainer.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.SingletonContainer">
            <summary>
            The SingletonContainer is a lifecycle container that when used on an export makes it into a singleton
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonContainer.Dispose">
            <summary>
            Dispose of the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonContainer.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.SingletonContainer.Clone">
            <summary>
            This method is used to clone a lifecycle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.LifeCycleContainers.SingletonContainer.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.ThreadStaticContainer">
            <summary>
            Thread static container will share an export per thread
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.ThreadStaticContainer.Dispose">
            <summary>
            Dispose the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.ThreadStaticContainer.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.ThreadStaticContainer.Clone">
            <summary>
            This method is used to clone a lifecycle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.LifeCycleContainers.ThreadStaticContainer.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.LifeCycleContainers.WeakSingletonContainer">
            <summary>
            The WeakSingletonContainer class will create an instance of the object and keep a weak reference to it
            A new instance will be requested upon request if the previous instance has been GC'd
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.WeakSingletonContainer.Dispose">
            <summary>
            Dispose of container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.WeakSingletonContainer.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.LifeCycleContainers.WeakSingletonContainer.Clone">
            <summary>
            This method is used to clone a lifecycle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.LifeCycleContainers.WeakSingletonContainer.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Owned`1">
            <summary>
            THis class can be used to scope 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Owned`1.SetValue(`0)">
            <summary>
            Sets the export value. It will only work once.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Owned`1.Value">
            <summary>
            The export value that is owned
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.DependencyResolveException">
            <summary>
            Exception thrown when you can't resolve a dependency
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.DependencyResolveException.#ctor(System.Type,System.String,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="injectedType"></param>
            <param name="injectedName"></param>
            <param name="importName"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DependencyResolveException.InjectedType">
            <summary>
            Type being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DependencyResolveException.InjectedName">
            <summary>
            Name of property or parameter being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DependencyResolveException.ImportName">
            <summary>
            Export name or Type that is being located
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ResolveUnknownExportArgs">
            <summary>
            This event arg can be handled to resolve unknown types.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ResolveUnknownExportArgs.#ctor(Grace.DependencyInjection.IInjectionContext,System.String,System.Type)">
            <summary>
            CSTOR
            </summary>
            <param name="injectionContext"></param>
            <param name="requestedName"></param>
            <param name="requestedType"></param>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.InjectionContext">
            <summary>
            Injection context for the resolve request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.RequestedName">
            <summary>
            The name of the export that was requested. Typically the full type name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.RequestedType">
            <summary>
            The type that was requested, can be null if requested by name only
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.ExportedValue">
            <summary>
            You can provide an export value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.TypeFilterGroup">
            <summary>
            Groups together a set of type filters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypeFilterGroup.#ctor(System.Func{System.Type,System.Boolean}[])">
            <summary>
            Default Constructor
            </summary>
            <param name="typeFilters"></param>
        </member>
        <member name="M:Grace.DependencyInjection.TypeFilterGroup.op_Implicit(Grace.DependencyInjection.TypeFilterGroup)~System.Func{System.Type,System.Boolean}">
            <summary>
            Automatically convert from TypefilterGroup to Func(Type,bool)
            </summary>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.TypesThat">
            <summary>
            That class provides Type filter methods to be used in ExportInterfaces and SelectTypes method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThatConfiguration.op_Implicit(Grace.DependencyInjection.TypesThatConfiguration)~System.Func{System.Type,System.Boolean}">
            <summary>
            Automatically convert from TypefilterGroup to Func(Type,bool)
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.DebugConsoleLog">
            <summary>
            Logs all message to debug console
            </summary>
        </member>
        <member name="T:Grace.Logging.ILog">
            <summary>
            an instance of a log
            </summary>
        </member>
        <member name="M:Grace.Logging.ILog.Debug(System.Object,System.Exception)">
            <summary>
            Log a Debug message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.DebugFormat(System.String,System.Object[])">
            <summary>
            Log a Debug formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Info(System.Object,System.Exception)">
            <summary>
            Log a Info message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.InfoFormat(System.String,System.Object[])">
            <summary>
            Log a Info formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Warn(System.Object,System.Exception)">
            <summary>
            Log a Warn message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.WarnFormat(System.String,System.Object[])">
            <summary>
            Log a Warn formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Error(System.Object,System.Exception)">
            <summary>
            Log an Error message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Log an Error format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.ILog.Fatal(System.Object,System.Exception)">
            <summary>
            Log an Fatal message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.ILog.FatalFormat(System.String,System.Object[])">
            <summary>
            Log an Fatal format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.ILog.IsDebugEnabled">
            <summary>
            Is Debug Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsInfoEnabled">
            <summary>
            Is Info Log Level  Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsWarnEnabled">
            <summary>
            Is Warn Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsErrorEnabled">
            <summary>
            Is Error Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsFatalEnabled">
            <summary>
            Is Fatal Log Level Enabled
            </summary>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.#ctor(System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="logName"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Debug(System.Object,System.Exception)">
            <summary>
            Log a Debug message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.DebugFormat(System.String,System.Object[])">
            <summary>
            Log a Debug formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Info(System.Object,System.Exception)">
            <summary>
            Log a Info message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.InfoFormat(System.String,System.Object[])">
            <summary>
            Log a Info formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Warn(System.Object,System.Exception)">
            <summary>
            Log a Warn message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.WarnFormat(System.String,System.Object[])">
            <summary>
            Log a Warn formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Error(System.Object,System.Exception)">
            <summary>
            Log an Error message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Log an Error format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Fatal(System.Object,System.Exception)">
            <summary>
            Log an Fatal message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.FatalFormat(System.String,System.Object[])">
            <summary>
            Log an Fatal format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsDebugEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsInfoEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsWarnEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsErrorEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsFatalEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="T:Grace.Logging.DebugConsoleLogService">
            <summary>
            Log service that writes everything to the debug console
            </summary>
        </member>
        <member name="T:Grace.Logging.ILogService">
            <summary>
            Log service to be used by Logger
            </summary>
        </member>
        <member name="M:Grace.Logging.ILogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.ILogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.DevNullLog">
            <summary>
            Logger that does nothing
            </summary>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Debug(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.DebugFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Info(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.InfoFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Warn(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.WarnFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Error(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Fatal(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.FatalFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsDebugEnabled">
            <summary>
            Is Debug Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsInfoEnabled">
            <summary>
            Is Info Log Level  Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsWarnEnabled">
            <summary>
            Is Warn Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsErrorEnabled">
            <summary>
            Is Error Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsFatalEnabled">
            <summary>
            Is Fatal Log Level Enabled, always false
            </summary>
        </member>
        <member name="T:Grace.Logging.DevNullLogService">
            <summary>
            Returns loggers that do nothing
            </summary>
        </member>
        <member name="M:Grace.Logging.DevNullLogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DevNullLogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.Logger">
            <summary>
            Static logging class for the framework. 
            </summary>
        </member>
        <member name="M:Grace.Logging.Logger.SetLogService(Grace.Logging.ILogService)">
            <summary>
            Set the logger to be used for the containers
            </summary>
            <param name="logService"></param>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger(System.Type)">
            <summary>
            Get an ILog instance
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger``1">
            <summary>
            Get an ILog instance
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger(System.String)">
            <summary>
            Get an ILog by name
            </summary>
            <param name="logName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.Debug(System.String,System.String,System.Exception)">
            <summary>
            Log a debug message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.Logger.Error(System.String,System.String,System.Exception)">
            <summary>
            Log an error message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="P:Grace.Logging.Logger.LogService">
            <summary>
            Get the log service for the framework
            </summary>
        </member>
        <member name="T:Grace.Logging.LogLevel">
            <summary>
            Log Level enumeration
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Debug">
            <summary>
            Debug level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Info">
            <summary>
            Info Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Warn">
            <summary>
            Warn Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Error">
            <summary>
            Error Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Fatal">
            <summary>
            Fatal Level
            </summary>
        </member>
        <member name="T:Grace.Utilities.TaskHelper">
            <summary>
            Utility methods to help with creating tasks
            </summary>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.CreateEmptyTask">
            <summary>
            Creates a new empty task
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.NullTask``1">
            <summary>
            Creates a null task
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.ReturnTask``1(``0)">
            <summary>
            Returns a value as a task
            </summary>
            <typeparam name="T"></typeparam>
            <param name="returnValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Utilities.WeakAction">
            <summary>
            Represents a delegate that will not hold a reference to it's target
            </summary>
        </member>
        <member name="M:Grace.Utilities.WeakAction.#ctor(System.Action)">
            <summary>
            Default Action
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Grace.Utilities.WeakAction.Invoke">
            <summary>
            Invoke the action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction.IsAlive">
            <summary>
            True if Target is alive
            </summary>
        </member>
        <member name="T:Grace.Utilities.WeakFunc`1">
            <summary>
            Represents a Func(T) that will not hold a reference to the target
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`1.#ctor(System.Func{`0})">
            <summary>
            Default Constructor
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`1.Invoke">
            <summary>
            Invoke the Func
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`1.IsAlive">
            <summary>
            Is the target alive
            </summary>
        </member>
    </members>
</doc>
